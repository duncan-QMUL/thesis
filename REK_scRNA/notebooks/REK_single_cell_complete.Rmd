---
title: "R Notebook"
output: html_notebook
---
Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

```{r}
#some ideas taken from here https://www.bioinformatics.babraham.ac.uk/training/10XRNASeq/seurat_workflow.html

# install.packages(c("tidyverse", "biomaRt","ggthemes","data.table","patchwork","Seurat", "reshape2"))


#load libraries
library(dplyr)
library(Seurat)
library(patchwork)
library(data.table)
library(stringr)
library(ggplot2)
library("biomaRt") 
library(ggthemes)
library(reshape2)
library(tidyverse)
library(RColorBrewer)
library(ggsci)
library(scCustomize)
library(here)

set.seed(42)


#load the dataset from the raw data downloaded
kerato.data <- Read10X(data.dir = here("REK_scRNA","rawdata"))
                        

#initialise the seurat object with the raw (non-normalised) data.
kerato <- CreateSeuratObject(counts = kerato.data, project = "Kerato", min.cells = 3, min.features = 100)
kerato

# set cluster colours for functions later. 
plot.colours <- c("#f87269","#80b00e","#00bdc2","#c679ff")
```

```{r}
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats. Added percentage of mitochondrial RNA per barcode to 'percent.mt'. 

grep("^Mt-",rownames(kerato@assays$RNA@counts),value = TRUE)

kerato[["percent.mt"]] <- PercentageFeatureSet(kerato, pattern = "^Mt-")

# show example metadata present. 
head(kerato@meta.data, 5)


```

```{r}
#ribosomal genes

grep("^Rp[ls]",rownames(kerato@assays$RNA@counts),value = TRUE)

kerato[["percent.ribosomal"]] <- PercentageFeatureSet(kerato,pattern="^Rp[ls]") 

head(kerato$percent.ribosomal)
```

```{r}
# Visualize QC metrics as a violin plot
VlnPlot(kerato, features = c("nFeature_RNA", "nCount_RNA"))

VlnPlot(kerato, features = c("percent.mt", "percent.ribosomal"))


VlnPlot(kerato, features = c("nFeature_RNA", "nCount_RNA")) + scale_y_log10()

VlnPlot(kerato, features = c("percent.mt", "percent.ribosomal")) + scale_y_log10()

```
```{r}
#In this example we run apply over the columns (cells) and calculate what percentage of the data comes from the single most observed gene. Again, having a high proportion of your data dominated by a single gene would be a concerning sign. We will also look later at the specific most highly expressed genes.


kerato[rownames(kerato) != "Malat1",] -> kerato.nomalat

apply(
  kerato.nomalat@assays$RNA@counts,
  2,
  max
) -> kerato.nomalat$largest_count

apply(
  kerato.nomalat@assays$RNA@counts,
  2,
  which.max
) -> kerato.nomalat$largest_index

rownames(kerato.nomalat)[kerato.nomalat$largest_index] -> kerato.nomalat$largest_gene

100 * kerato.nomalat$largest_count / kerato.nomalat$nCount_RNA -> kerato.nomalat$percent.Largest.Gene

kerato$largest_gene <- kerato.nomalat$largest_gene
kerato$percent.Largest.Gene <- kerato.nomalat$percent.Largest.Gene
# 
# rm(kerato.nomalat) #will remove the nomalat columns
#no malat cells not removed due to reducing levels too much. 

kerato
```

```{r}
#create table of QC metrics and name largest gene. 

as_tibble(
  kerato[[]],
  rownames="Cell.Barcode"
) -> qc.metrics

qc.metrics
```
```{r}
# plot features and counts with mito colouring of points
qc.metrics %>%
  arrange(percent.mt) %>%
  ggplot(aes(nCount_RNA,nFeature_RNA,colour=percent.mt)) + 
  geom_point() + 
  scale_color_gradientn(colours=c("black","blue","green2","red","yellow")) +
  ggtitle("Example of plotting QC metrics") +
  geom_hline(yintercept = 200) +
  geom_hline(yintercept = 6000) + theme_calc() +
  theme(panel.grid.major.x = element_line(colour = 'light grey')) +
  xlab("Number of counts") + 
  ylab("Number of features") + labs(colour = "% mitochondrial RNA")
```

```{r}
#plotting complexity
# The standard way of calculating this is log10(genes)/log10(counts) however this gives absolute values which are difficult to judge. A possibly better approach is to fit a line through the cloud and then calculate the difference from the observed value to the expected.

qc.metrics %>%
  mutate(complexity=log10(nFeature_RNA) / log10(nCount_RNA))  -> qc.metrics

lm(log10(qc.metrics$nFeature_RNA)~log10(qc.metrics$nCount_RNA)) -> complexity.lm

complexity.lm

qc.metrics %>%
  mutate(
    complexity_diff = log10(nFeature_RNA) - ((log10(qc.metrics$nCount_RNA)*complexity.lm$coefficients[2])+complexity.lm$coefficients[1])
  ) -> qc.metrics

qc.metrics %>%
  ggplot(aes(x=complexity_diff)) +
  geom_density(fill="yellow") +
  xlab("Complexity differential") + 
  ylab("Density") +
  theme_calc() + geom_vline(xintercept = 0)
```
```{r}

# create complexity scale
min(c(max(qc.metrics$complexity_diff),0-min(qc.metrics$complexity_diff))) -> complexity_scale

# plot log10(features) and log10(counts) with complexity differential colouring of points
qc.metrics %>%
  mutate(complexity_diff=replace(complexity_diff,complexity_diff< -0.1,-0.1)) %>%
  ggplot(aes(x=log10(nCount_RNA), y=log10(nFeature_RNA), colour=complexity_diff)) +
  geom_point(size=0.5) +
  geom_abline(slope=complexity.lm$coefficients[2], intercept = complexity.lm$coefficients[1]) +
  scale_colour_gradient2(low="blue2",mid="grey",high="red2") +
  xlab("log10(counts)") + 
  ylab("log10(features)") +
  labs(colour = "Complexity differential") + 
  theme_calc() +
  theme(panel.grid.major.x = element_line(colour = 'light grey'))
```
```{r}
# add generated metadata here
complexity.diff <- qc.metrics %>% pull(complexity_diff)

kerato@meta.data <- cbind(kerato@meta.data, complexity.diff)

```

```{r}
# plot log10(features) and log10(counts) with mito colouring of points
qc.metrics.log10.scatter <- qc.metrics %>%
  arrange(percent.mt) %>%
  ggplot(aes(nCount_RNA,nFeature_RNA,colour=percent.mt)) + 
  geom_point(size=0.7) + 
  scale_color_gradientn(colors=c("black","blue","green2","red","yellow")) +
  ggtitle("QC metrics across barcodes") +
  geom_abline(slope=complexity.lm$coefficients[2], intercept = complexity.lm$coefficients[1]) +
  geom_hline(yintercept = 200) +
  geom_hline(yintercept = 6000) +
  scale_x_log10() + scale_y_log10() +
  xlab("Log10(Number of counts)") + 
  ylab("Log10(Number of features)") +
  labs(colour = "% mitochondrial RNA") + theme_calc() +
  theme(panel.grid.major.x = element_line(colour = 'light grey'))

ggsave("qc_log10_scatter.tiff", plot = print(qc.metrics.log10.scatter, device = "tiff", height = 336, width = 544, units = "px"))

```

```{r}
# plot log10(features) and log10(counts) with ribosomal colouring of points
qc.metrics %>%
  arrange(percent.mt) %>%
  ggplot(aes(nCount_RNA,nFeature_RNA,colour=percent.ribosomal)) + 
  geom_point(size=0.7) + 
  scale_color_gradientn(colors=c("black","blue","green2","red","yellow")) +
  ggtitle("QC metrics across barcodes") +
  geom_hline(yintercept = 200) +
  geom_hline(yintercept = 6000) + geom_abline(slope=complexity.lm$coefficients[2], intercept = complexity.lm$coefficients[1]) +
  scale_x_log10() + scale_y_log10() +
  xlab("Log10(Number of counts)") + 
  ylab("Log10(Number of features)") +
  labs(colour = "% ribosomal RNA") + theme_calc() +
  theme(panel.grid.major.x = element_line(colour = 'light grey'))
```
```{r}
# plot largest gene with ribosomal mRNA with complexity differential colouring of points
qc.metrics %>%
  ggplot(aes(x=percent.Largest.Gene, y=percent.ribosomal, colour = complexity_diff)) +
  geom_point() + 
  geom_smooth(method = "lm")+
  xlab("% largest gene") + 
  ylab("% ribosomal genes") +
  ylim(0, NA) +
  theme_calc() +
  theme(panel.grid.major.x = element_line(colour = 'light grey')) + scale_color_gradientn(colors=c("black","blue","green2","red","yellow"))
  
```

```{r}
# plot largest gene with mito RNA with complexity differential colouring of points
qc.metrics %>%
  ggplot(aes(x=percent.Largest.Gene, y=percent.mt, colour = complexity_diff)) +
  geom_point() + 
  geom_smooth(method = "lm")+
  xlab("% largest gene") + 
  ylab("% mitochondrial genes") +
  ylim(0, NA)+
  theme_calc() +
  theme(panel.grid.major.x = element_line(colour = 'light grey')) + scale_color_gradientn(colors=c("black","blue","green2","red","yellow"))

```


```{r}
# create a largest gene list
qc.metrics %>%
  group_by(largest_gene) %>%
  count() %>%
  arrange(desc(n)) -> largest_gene_list

largest_gene_list

# make list of largest genes to plot
largest_gene_list %>%
  filter(n>5) %>%
  pull(largest_gene) -> largest_genes_to_plot

# plot log10(features) and log10(counts) with largest gene colouring of points
qc.metrics %>%
  filter(largest_gene %in% largest_genes_to_plot) %>%
  mutate(largest_gene=factor(largest_gene, levels=largest_genes_to_plot)) %>%
  arrange(largest_gene) %>%
  ggplot(aes(x=log10(nCount_RNA), y=log10(nFeature_RNA), colour=largest_gene)) +
  geom_point(size=1) +
  scale_colour_manual(values=c("grey",RColorBrewer::brewer.pal(9,"Set1"))) +
  xlab("log10(counts)") + 
  ylab("log10(features)") +
  labs(colour = "Largest gene") + 
  theme_calc() +
  theme(panel.grid.major.x = element_line(colour = 'light grey'))
```
```{r}
# plot complexity diff against largest gene
qc.metrics %>%
  filter(largest_gene %in% largest_genes_to_plot) %>%
  mutate(largest_gene=factor(largest_gene, levels=largest_genes_to_plot)) %>%
  arrange(largest_gene) %>%
  ggplot(aes(x=complexity_diff, y=percent.Largest.Gene, colour=largest_gene)) +
  geom_point()+
  scale_colour_manual(values=c("grey",RColorBrewer::brewer.pal(9,"Set1"))) + 
  xlab("Complexity differential") + 
  ylab("% largest gene") +
  labs(colour = "Largest gene") +
  theme_calc() +
  theme(panel.grid.major.x = element_line(colour = 'light grey'))
```
```{r}
# plot complexity diff against largest gene with mito percentage
qc.metrics %>%
  arrange(percent.mt) %>%
  ggplot(aes(x=complexity_diff, y=percent.Largest.Gene, colour=percent.mt)) +
  geom_point() +
  scale_color_gradientn(colors=c("black","blue","green2","red","yellow")) +
  xlab("Complexity differential") + 
  ylab("% largest gene") +
  labs(colour = "% mitochondrial RNA") +
  theme_calc() +
  theme(panel.grid.major.x = element_line(colour = 'light grey'), axis.line=element_line(color="black"), axis.line.y = element_line(color="black"), text = element_text(size =  12))

```
```{r}
# plot complexity diff against % mito with largest gene
qc.metrics %>%
  arrange(percent.mt) %>%
  ggplot(aes(x=complexity_diff, y=percent.mt, colour=percent.Largest.Gene)) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_color_gradientn(colors=c("black","blue","green2","red","yellow")) +
  xlab("Complexity differential") + 
  ylab("% mitochondrial RNA") +
  labs(colour = "% largest gene") +
  theme_calc() +
  theme(panel.grid.major.x = element_line(colour = 'light grey'), axis.line=element_line(color="black"), axis.line.y = element_line(color="black"), text = element_text(size =  12))
```


```{r}
# plot complexity diff against largest gene with ribo percentage
qc.metrics %>%
  arrange(percent.ribosomal) %>%
  ggplot(aes(x=complexity_diff, y=percent.Largest.Gene, colour=percent.ribosomal)) +
  geom_point() +
  scale_color_gradientn(colors=c("black","blue","green2","red","yellow")) +
  xlab("Complexity differential") + 
  ylab("% largest gene") +
  labs(colour = "% ribosomal mRNA") +
  
  theme_calc() +
  theme(panel.grid.major.x = element_line(colour = 'light grey'), axis.line=element_line(color="black"), axis.line.y = element_line(color="black"), text = element_text(size =  12)) 
```
```{r}
# plot complexity diff against ribo % with largest gene colouring
qc.metrics %>%
  arrange(percent.mt) %>%
  ggplot(aes(x=complexity_diff, y=percent.ribosomal, colour=percent.Largest.Gene)) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_color_gradientn(colors=c("black","blue","green2","red","yellow")) +
  xlab("Complexity differential") + 
  ylab("% ribosomal mRNA") +
  labs(colour = "% largest gene") +
  theme_calc() +
  theme(panel.grid.major.x = element_line(colour = 'light grey'), axis.line=element_line(color="black"), axis.line.y = element_line(color="black"), text = element_text(size =  12))
```

```{r}
# Distribution of percentage mitochondrial RNA
qc.metrics %>%
  ggplot(aes(percent.mt)) + 
  geom_histogram(binwidth = 0.5, fill="yellow", colour="black") +
  ggtitle("Distribution of percentage mitochondrial RNA") +
  geom_vline(xintercept = 50) +
  xlab("% mitochondrial RNA") + 
  ylab("Count") +
  theme_gdocs()
```

```{r}
# Distribution of Percentage Largest Gene
qc.metrics %>%
  ggplot(aes(percent.Largest.Gene)) + 
  geom_histogram(binwidth = 0.7, fill="coral", colour="black") +
  ggtitle("Distribution of Percentage Largest Gene") +
  xlab("% largest gene") + 
  ylab("Count") +
  theme_gdocs()
```

```{r}
# GAPDH expression distribution
ggplot(mapping = aes(kerato@assays$RNA@data["Gapdh",])) + 
  geom_histogram(binwidth = 0.05, fill="coral", colour="black") + 
  ggtitle("GAPDH expression distribution") +
  xlab("GADPH Expression") + 
  ylab("Count") +
  theme_calc()
```

```{r}
# summarise metadata
summary(kerato@meta.data)
```

```{r}
# make new dataframe with superfluous info removed
keep.columns <- c("Cell.Barcode","nCount_RNA","nFeature_RNA","percent.mt","percent.ribosomal","percent.Largest.Gene")
melt.qc <- qc.metrics[keep.columns]


# melt the dataframe so boxplot of QCs can be generated
melt.qc <- melt(melt.qc, id="Cell.Barcode")

# plot violin plots of metrics
qc.metrics.violin <- ggplot(melt.qc, aes(x = variable, y = value)) + 
geom_violin(aes(x = variable, y = value, fill = variable)) + geom_jitter(size = 0.2, position = position_jitter(seed= 1, width = 0.2)) + facet_wrap(~ variable, scales = "free")  +
  theme_calc() + theme(title = element_blank(), axis.text.x = element_blank(), strip.text = element_blank(), legend.position = c(0.85, 0.2)) +labs(colour = "Measurement", x = element_blank(), y = "Value") + scale_fill_npg(name = "Measurement", labels=c("Number of counts", "Number of features","% mtRNA", "% ribosomal genes","% largest gene" ))

qc.metrics.violin

ggsave("qc_violins.tiff", plot = print(qc.metrics.violin, device = "tiff", dpi = 400))

# plot violin plots of metrics with logarithmic scaled values
qc.metrics.violin.log10 <- ggplot(melt.qc, aes(x = variable, y = value)) + 
geom_violin(aes(x = variable, y = value, fill = variable)) + geom_jitter(size = 0.2, position = position_jitter(seed= 1, width = 0.2)) + facet_wrap(~ variable, scales = "free")  + scale_y_log10()+
  theme_calc() + theme(title = element_blank(), axis.text.x = element_blank(), strip.text = element_blank(), legend.position = c(0.85, 0.2)) +labs(colour = "Measurement", x = element_blank(), y = "Log10(Measurement Value)") + scale_fill_npg(name = "Measurement", labels=c("Number of counts", "Number of features","% mtRNA", "% ribosomal genes","% largest gene" ))

qc.metrics.violin.log10

ggsave("qc_violins_log10.tiff", plot = print(qc.metrics.violin.log10, device = "tiff", dpi = 400))

```

```{r}
# here is where we filter with QC metrics, look at violin plots to see number of cells excluded. Will need high mt% and low feature no. to process majority of cells
kerato <- subset(kerato, subset = nFeature_RNA > 200 & nFeature_RNA < 6000 & percent.mt < 50)

kerato_info <- kerato@meta.data %>% as.data.frame()
## extract meta data
# the resulting object has one "row" per cell
cat('Number of cells in analysis:', nrow(kerato_info))
#number of cells pulled through using the filters above is printed to the terminal.

```
```{r}
#log normalisation of data
kerato <- NormalizeData(kerato, normalization.method = "LogNormalize", scale.factor = 10000)
```


```{r}
# Basic function to convert human gene names to corresponding rat genes
convertHumanGeneList <- function(x){
require("biomaRt")
  
# marts contain the gene analogs between species, so can be used for comparison
# find human gene list
human.mart <- biomaRt::useMart(host="https://dec2021.archive.ensembl.org", "ENSEMBL_MART_ENSEMBL", dataset="hsapiens_gene_ensembl")

# find rat gene list
rat.mart <- biomaRt::useMart(host="https://dec2021.archive.ensembl.org", "ENSEMBL_MART_ENSEMBL", dataset="rnorvegicus_gene_ensembl")

# get the gene analogs from the marts and cross compare
genesV2 = getLDS(attributes = c("hgnc_symbol"), 
                 filters = "hgnc_symbol", 
                 values = x , 
                 mart = human.mart, 
                 attributesL = c("rgd_symbol"), 
                 martL = rat.mart, 
                 uniqueRows=T)

ratx <- unique(genesV2[, 2])
# Print the first 6 genes found to the screen
print(head(ratx))
return(ratx)
}

# build rat S-phase and G2M phase gene lists
r.s.genes <- convertHumanGeneList(cc.genes.updated.2019$s.genes)
r.g2m.genes <- convertHumanGeneList(cc.genes.updated.2019$g2m.genes)

# printout to show completion of task
head(r.s.genes)
head(r.g2m.genes)

# comparison of lengths
length(cc.genes.updated.2019$s.genes)
length(r.s.genes)

length(cc.genes.updated.2019$g2m.genes)
length(r.g2m.genes)
```

```{r}
# cell cycle scoring system to assign cell phase identities to each barcode
kerato <- CellCycleScoring(kerato, s.features = r.s.genes, g2m.features = r.g2m.genes, set.ident = TRUE) 

kerato[[]]

```
```{r}

kerato.tbl <- as_tibble(kerato[[]])                                                # Replicate original data
kerato.tbl$Phase <- factor(kerato.tbl$Phase,                                    # Change ordering manually
                  levels = c("G1","S","G2M")) 

# bar chart of cell phases
kerato.tbl %>%
  ggplot(aes(Phase)) + geom_bar(aes(fill = Phase)) + theme_calc() + scale_fill_npg()

# scatterplot of cell phases using scores as axes
kerato.tbl %>%
  ggplot(aes(x=S.Score, y=G2M.Score, color=Phase)) + 
  geom_point() +
  coord_cartesian(xlim=c(-0.15,0.15), ylim=c(-0.15,0.15)) +
  theme_calc() +
  theme(panel.grid.major.x = element_line(colour = 'light grey'), axis.line=element_line(color="black"), axis.line.y = element_line(color="black"), text = element_text(size =  12)) +scale_color_npg()

# tabulate the phases
table(kerato.tbl$Phase)
```


```{r}
#finding HVGs
# vst: First, fits a line to the relationship of log(variance) and log(mean) using local polynomial regression (loess). Then standardizes the feature values using the observed mean and expected variance (given by the fitted line). Feature variance is then calculated on the standardized values after clipping to a maximum (see clip.max parameter).
kerato <- FindVariableFeatures(kerato, selection.method = "vst", nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(kerato), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(kerato)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1 
plot2
```
```{r}
# create variance dataframe for later plotting
as_tibble(HVFInfo(kerato),rownames = "Gene") -> variance.data

variance.data %>% 
  mutate(hypervariable=Gene %in% VariableFeatures(kerato)
) -> variance.data

head(variance.data, n=10)

# variance data scatterplot
variance.data %>% 
  ggplot(aes(log(mean),log(variance),color=hypervariable)) + 
  geom_point() + 
  scale_color_manual(values=c("black","red")) +
  labs(colour = "Hypervariable?") +
  theme_calc() +
  theme(panel.grid.major.x = element_line(colour = 'light grey'), axis.line=element_line(color="black"), axis.line.y = element_line(color="black"), text = element_text(size =  12))
```

```{r}
#Next, we apply a linear transformation ('scaling') that is a standard pre-processing step prior to dimensional reduction techniques like PCA. The ScaleData function:

#Shifts the expression of each gene, so that the mean expression across cells is 0
#Scales the expression of each gene, so that the variance across cells is 1
#This step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate
#The results of this are stored in pbmc[["RNA"]]@scale.data
all.genes <- rownames(kerato)
kerato <- ScaleData(kerato, features = all.genes)
```




```{r}
#run the PCA analysis of the dataset
kerato <- RunPCA(kerato, features = VariableFeatures(object = kerato))

# Examine and visualize PCA results a few different ways
print(kerato[["pca"]], dims = 1:5, nfeatures = 5)
```
```{r}
#visualise the PCA coordinates of genes, loading plots indicate what factors contribute most to variability. 
VizDimLoadings(kerato, dims = 1, nfeatures = 20, reduction = "pca") + coord_flip() + theme(axis.text.x = element_text(size = 6,angle = 45, vjust=1, hjust = 1))+ scale_colour_npg()


# plot cells using two PCAs as axis. 
DimPlot(kerato, reduction = "pca")
```


```{r}
# DimHeatmap allows for easy exploration of the primary sources of heterogeneity in a dataset, and can be useful when trying to decide which PCs to include for further downstream analyses. Both cells and features are ordered according to their PCA scores. 
DimHeatmap(kerato, dims = 1:2, nfeatures = 20,cells = 300, fast = F) 
DimHeatmap(kerato, dims = 3:4, nfeatures = 20,cells = 300, fast = F)
DimHeatmap(kerato, dims = 5:6, nfeatures = 20,cells = 300, fast = F)
DimHeatmap(kerato, dims = 7:8, nfeatures = 20,cells = 300, fast = F)
```
```{r}
# NOTE: This process can take a long time for big datasets, comment out for expediency. More approximate techniques such as those implemented in ElbowPlot() can be used to reduce computation time
# kerato <- JackStraw(kerato, num.replicate = 100)
# kerato <- ScoreJackStraw(kerato, dims = 1:20)
# 
# JackStrawPlot(kerato, dims = 1:15)
```
```{r}
#elbow plot , shows SD of PCs, elbow is where significance should begin to be negligible.
ElbowPlot(kerato)
```

```{r}
#Here is where we optimise the number of PCs used to cluster the cells, and the resolution of the clustering algorithm.
kerato <- FindNeighbors(kerato, dims = 1:7)
kerato <- FindClusters(kerato, resolution = 0.4)

head(Idents(kerato), 5)
```


```{r}
#Plot UMAP
kerato <- RunUMAP(kerato, dims = 1:7)

DimPlot(kerato, reduction = "umap")
FeaturePlot(kerato, feature = "complexity.diff")
# DimPlot(kerato, reduction = "pca")
```

```{r}
# cell cycle phase per cluster %
kerato@meta.data %>%
  group_by(seurat_clusters,Phase) %>%
  count() %>%
  group_by(seurat_clusters) %>%
  mutate(percent=100*n/sum(n)) %>%
  ungroup() %>%
  ggplot(aes(x=seurat_clusters,y=percent, fill=Phase)) +
  geom_col() +
  ggtitle("Percentage of cell cycle phases per cluster") + theme_calc() + labs( x = "Cluster", y = "Percent")
```
```{r}
# violin plots of QC metrics per cluster

VlnPlot(kerato,features="percent.Largest.Gene") + labs(title = "Percentage largest gene", x = "Cluster")
VlnPlot(kerato,features="percent.ribosomal") + labs(title = "Percentage ribosomal genes", x = "Cluster")
VlnPlot(kerato,features="percent.mt") + labs(title = "Percentage mitochondrial genes", x = "Cluster")
VlnPlot(kerato,features="nFeature_RNA") + labs(title = "Features per barcode", x = "Cluster")
VlnPlot(kerato,features="nCount_RNA") + labs(title = "Counts per barcode", x = "Cluster")


```
```{r}
# UMAP showing facets of the largest gene locations

kerato@reductions$umap@cell.embeddings %>%
  as_tibble() %>%
  add_column(seurat_clusters=kerato$seurat_clusters, largest_gene=kerato$largest_gene) %>%
  filter(largest_gene %in% largest_genes_to_plot) %>%
  ggplot(aes(x=UMAP_1, y=UMAP_2, colour=seurat_clusters)) +
  geom_point() +
  facet_wrap(vars(largest_gene)) +theme_classic()
```
```{r}
# UMAP of the phases facetted by cluster
png("images_out/umap/phases_and_clusters.png",width = 400, height = 600)
kerato@reductions$umap@cell.embeddings %>%
  as_tibble() %>%
  add_column(seurat_clusters=kerato$seurat_clusters, Phase=kerato$Phase) %>%
  ggplot(aes(x=UMAP_1, y=UMAP_2, colour=seurat_clusters)) +
  geom_point() +
  facet_grid(vars(Phase)) + theme_classic() + labs(colour = "Cluster", x = "UMAP 1", y = "UMAP 2")
dev.off()
```

```{r}
#You can save the object at this point so that it can easily be loaded back in without having to rerun the computationally intensive steps performed above, or easily shared with collaborators.
saveRDS(kerato, file = here("REK_scRNA","temp","smalllargekera.rds"))

old.kerato <- readRDS(here("REK_scRNA","temp","pseudoSLkera.rds"))
DimPlot(old.kerato, reduction = "umap")
DimPlot(kerato, reduction = "umap")
```
```{r}
# plot QC metrics on UMAP

FeaturePlot(kerato,feature = "complexity.diff")  + scale_color_gradientn(colors=c("black","purple","yellow")) + labs(x = "UMAP 1", y = "UMAP 2", title = "Complexity Differential")  

FeaturePlot(kerato,feature = "nCount_RNA")  + scale_color_gradientn(colors=c("black","purple","yellow")) + labs(x = "UMAP 1", y = "UMAP 2", title = "Counts per barcode")  

FeaturePlot(kerato,feature = "nFeature_RNA")  + scale_color_gradientn(colors=c("black","purple","yellow")) + labs(x = "UMAP 1", y = "UMAP 2", title = "Features per barcode") 

FeaturePlot(kerato,feature = "percent.mt")  + scale_color_gradientn(colors=c("black","purple","yellow")) + labs(x = "UMAP 1", y = "UMAP 2", title = "Percentage mitochondrial genes") 

FeaturePlot(kerato,feature = "percent.ribosomal")  + scale_color_gradientn(colors=c("black","purple","yellow")) + labs(x = "UMAP 1", y = "UMAP 2", title = "Percentage ribosomal genes") 

FeaturePlot(kerato,feature = "percent.Largest.Gene")  + scale_color_gradientn(colors=c("black","purple","yellow")) + labs(x = "UMAP 1", y = "UMAP 2", title = "Percentage largest genes") 


```
```{r}
# set marker gene vectors for different identities

basal.kerato.markers <- c("Krt14","Krt5","Cdh3","Krt15","Col17a1","Tp73","Fam83g","Fgfr3","Tp63","Bcl11b")
spinous.kerato.markers <- c("Cdh1","Krt1","Krt10","Dsg1","Lgal57","Hopx","Cyp4f22","Grhl1","Prgs1","Klk9")
granular.kerato.markers <- c("Dsc1","Krt2","Ivl","Tgm3","Kprp","Pof1b","Dnase1l2","Trex2","Otx1","Eps8l1","Card18")

```

```{r}
# heatmaps of kerato marker genes for different strata
# basal markers
png("images_out/vln_and_heat/basal_markers_heatmap.png",width = 600, height = 400)
DoHeatmap(kerato, features = basal.kerato.markers)
dev.off()

# spinous markers
png("images_out/vln_and_heat/spinous_markers_heatmap.png",width = 600, height = 350)
DoHeatmap(kerato, features = spinous.kerato.markers)
dev.off()

# granular markers
png("images_out/vln_and_heat/granular_markers_heatmap.png",width = 600, height = 300)
DoHeatmap(kerato, features = granular.kerato.markers)
dev.off()

```

```{r}
# violin plot of kerat markers
# basal markers
png("images_out/vln_and_heat/basal_markers_vln.png",width = 400, height = 500)
Stacked_VlnPlot(seurat_object = kerato, features = basal.kerato.markers, x_lab_rotate = TRUE, colors_use = plot.colours) 
dev.off()

# spinous markers
png("images_out/vln_and_heat/spinous_markers_vln.png",width = 400, height = 400)
Stacked_VlnPlot(seurat_object = kerato, features = spinous.kerato.markers, x_lab_rotate = TRUE, colors_use = plot.colours) 
dev.off()

# granular markers
png("images_out/vln_and_heat/granular_markers_vln.png",width = 400, height = 300)
Stacked_VlnPlot(seurat_object = kerato, features = granular.kerato.markers, x_lab_rotate = TRUE, colors_use = plot.colours) 
dev.off()
```
```{r}
# Post actin-intersection analysis

# Actin markers pulled out of clustering
# and respective plots
actin.cluster.markers <- c("Anxa1", "Sptbn2", "Rflnb", "Cavin3", "Tmsb4x", "Phpt1", "Cav1", "Ctsl", "Amotl2", "Hsp90b1", "Slc2a1", "Gmfg", "Dstn")


png("images_out/vln_and_heat/actin_markers_vln.png",width = 400, height = 650)
Stacked_VlnPlot(seurat_object = kerato, features = actin.cluster.markers, x_lab_rotate = TRUE, colors_use = plot.colours)
dev.off()


png("images_out/vln_and_heat/actin_markers_heatmap.png",width = 600, height = 500)
DoHeatmap(kerato, features = actin.cluster.markers)
dev.off()

```

